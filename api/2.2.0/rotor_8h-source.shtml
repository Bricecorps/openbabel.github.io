<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>Open Babel: rotor.h Source File</title>
<link href="/site.css" rel="stylesheet" type="text/css">
<link href="api-style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<body>

<!--#include file="header.html" -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.shtml"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.shtml"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.shtml"><span>Namespaces</span></a></li>
      <li><a href="classes.shtml"><span>Classes</span></a></li>
      <li class="current"><a href="files.shtml"><span>Files</span></a></li>
    </ul>
  </div>
<h1>rotor.h</h1><a href="rotor_8h.shtml">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**********************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">rotor.h - Rotate torsional according to rotor rules.</span>
<a name="l00003"></a>00003 <span class="comment"> </span>
<a name="l00004"></a>00004 <span class="comment">Copyright (C) 1998-2000 by OpenEye Scientific Software, Inc.</span>
<a name="l00005"></a>00005 <span class="comment">Some portions Copyright (C) 2001-2005 by Geoffrey R. Hutchison</span>
<a name="l00006"></a>00006 <span class="comment"> </span>
<a name="l00007"></a>00007 <span class="comment">This file is part of the Open Babel project.</span>
<a name="l00008"></a>00008 <span class="comment">For more information, see &lt;http://openbabel.sourceforge.net/&gt;</span>
<a name="l00009"></a>00009 <span class="comment"> </span>
<a name="l00010"></a>00010 <span class="comment">This program is free software; you can redistribute it and/or modify</span>
<a name="l00011"></a>00011 <span class="comment">it under the terms of the GNU General Public License as published by</span>
<a name="l00012"></a>00012 <span class="comment">the Free Software Foundation version 2 of the License.</span>
<a name="l00013"></a>00013 <span class="comment"> </span>
<a name="l00014"></a>00014 <span class="comment">This program is distributed in the hope that it will be useful,</span>
<a name="l00015"></a>00015 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00017"></a>00017 <span class="comment">GNU General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment">***********************************************************************/</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#ifndef OB_ROTOR_H</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#define OB_ROTOR_H</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="parsmart_8h.shtml" title="Daylight SMARTS parser.">openbabel/parsmart.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="typer_8h.shtml" title="Open Babel atom and aromaticity typer.">openbabel/typer.h</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="keyword">namespace </span>OpenBabel
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#ifndef SQUARE</span>
<a name="l00030"></a><a class="code" href="rotor_8h.shtml#a1cf70a99e21bc2032e8867c6cafbb43">00030</a> <span class="preprocessor"></span><span class="preprocessor">#define SQUARE(x) ((x)*(x))</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00040"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml">00040</a>   <span class="keyword">class </span>OBAPI <a class="code" href="classOpenBabel_1_1OBRotorRule.shtml" title="A rule for torsional conformer searching, defined by a SMARTS pattern.">OBRotorRule</a>
<a name="l00041"></a>00041   {
<a name="l00042"></a>00042     <span class="keywordtype">int</span>                 _ref[4]; 
<a name="l00043"></a>00043     <span class="keywordtype">double</span>              _delta;  
<a name="l00044"></a>00044     std::string         _s;      
<a name="l00045"></a>00045     <a class="code" href="classOpenBabel_1_1OBSmartsPattern.shtml" title="SMARTS (SMiles ARbitrary Target Specification) substructure searching.">OBSmartsPattern</a>*    _sp;     
<a name="l00046"></a>00046     std::vector&lt;double&gt; _vals;   
<a name="l00047"></a>00047   <span class="keyword">public</span>:
<a name="l00048"></a>00048   
<a name="l00049"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#c65f277d7001f0b88bfeb47c25490995">00049</a>   <a class="code" href="classOpenBabel_1_1OBRotorRule.shtml" title="A rule for torsional conformer searching, defined by a SMARTS pattern.">OBRotorRule</a>(<span class="keywordtype">char</span> *buffer,<span class="keywordtype">int</span> ref[4],std::vector&lt;double&gt; &amp;vals,<span class="keywordtype">double</span> d):
<a name="l00050"></a>00050     _delta(d), _s(buffer), _vals(vals)
<a name="l00051"></a>00051     {
<a name="l00052"></a>00052       _sp = <span class="keyword">new</span> <a class="code" href="classOpenBabel_1_1OBSmartsPattern.shtml" title="SMARTS (SMiles ARbitrary Target Specification) substructure searching.">OBSmartsPattern</a>;
<a name="l00053"></a>00053       _sp-&gt;Init(buffer);
<a name="l00054"></a>00054       memcpy(_ref,ref,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*4);
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056 
<a name="l00057"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#236044823d65dffe4868c831e45a157b">00057</a>     ~<a class="code" href="classOpenBabel_1_1OBRotorRule.shtml" title="A rule for torsional conformer searching, defined by a SMARTS pattern.">OBRotorRule</a>()
<a name="l00058"></a>00058       {
<a name="l00059"></a>00059         <span class="keywordflow">if</span> (_sp)
<a name="l00060"></a>00060           {
<a name="l00061"></a>00061             <span class="keyword">delete</span> _sp;
<a name="l00062"></a>00062             _sp = NULL;
<a name="l00063"></a>00063           }
<a name="l00064"></a>00064       }
<a name="l00065"></a>00065   
<a name="l00067"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#9dcb9b43a3d0fa9003d4c1c9d921f6b2">00067</a>     <span class="keywordtype">bool</span>    IsValid()    {        <span class="keywordflow">return</span>(_sp-&gt;IsValid());       }
<a name="l00071"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#6583697916569d12c1a113b4ad4dbcc2">00071</a>     <span class="keywordtype">void</span>    GetReferenceAtoms(<span class="keywordtype">int</span> ref[4]) { memcpy(ref,_ref,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*4); }
<a name="l00073"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#800aee2a9873012ac7e2a1bcedd5c6ba">00073</a>     <span class="keywordtype">void</span>    SetDelta(<span class="keywordtype">double</span> d)    {       _delta = d;           }
<a name="l00075"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#baa1b786f36fb9bc98b5c46e74425056">00075</a>     <span class="keywordtype">double</span>  GetDelta()            {       <span class="keywordflow">return</span>(_delta);       }
<a name="l00077"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#111e26305dbd8f7c211cc259dff440e7">00077</a>     std::vector&lt;double&gt;   &amp;GetTorsionVals()    { <span class="keywordflow">return</span>(_vals); }
<a name="l00079"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#84366a387431ba9c8ed2f3813e60badd">00079</a>     std::string  &amp;GetSmartsString(){      <span class="keywordflow">return</span>(_s);           }
<a name="l00081"></a><a class="code" href="classOpenBabel_1_1OBRotorRule.shtml#1b97208b08b2495efa0a4484b4d61938">00081</a>     <a class="code" href="classOpenBabel_1_1OBSmartsPattern.shtml" title="SMARTS (SMiles ARbitrary Target Specification) substructure searching.">OBSmartsPattern</a> *GetSmartsPattern() {  <span class="keywordflow">return</span>(_sp);         }
<a name="l00082"></a>00082   };
<a name="l00083"></a>00083 
<a name="l00090"></a><a class="code" href="classOpenBabel_1_1OBRotorRules.shtml">00090</a>  <span class="keyword">class </span>OBAPI <a class="code" href="classOpenBabel_1_1OBRotorRules.shtml" title="Database of default hybridization torsional rules and SMARTS-defined OBRotorRule...">OBRotorRules</a> : <span class="keyword">public</span> <a class="code" href="classOpenBabel_1_1OBGlobalDataBase.shtml" title="Base data table class, handles reading data files.">OBGlobalDataBase</a>
<a name="l00091"></a>00091   {
<a name="l00092"></a>00092     <span class="keywordtype">bool</span>                       _quiet;  
<a name="l00093"></a>00093     std::vector&lt;OBRotorRule*&gt;  _vr;     
<a name="l00094"></a>00094     std::vector&lt;double&gt;        _sp3sp3; 
<a name="l00095"></a>00095     std::vector&lt;double&gt;        _sp3sp2; 
<a name="l00096"></a>00096     std::vector&lt;double&gt;        _sp2sp2; 
<a name="l00097"></a>00097   <span class="keyword">public</span>:
<a name="l00098"></a>00098     <a class="code" href="classOpenBabel_1_1OBRotorRules.shtml" title="Database of default hybridization torsional rules and SMARTS-defined OBRotorRule...">OBRotorRules</a>();
<a name="l00099"></a>00099     ~<a class="code" href="classOpenBabel_1_1OBRotorRules.shtml" title="Database of default hybridization torsional rules and SMARTS-defined OBRotorRule...">OBRotorRules</a>();
<a name="l00100"></a>00100   
<a name="l00101"></a>00101     <span class="keywordtype">void</span> ParseLine(<span class="keyword">const</span> <span class="keywordtype">char</span>*);
<a name="l00103"></a><a class="code" href="classOpenBabel_1_1OBRotorRules.shtml#93721b9b970ca9a8160f7b831ae7e9d4">00103</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GetSize()                 { <span class="keywordflow">return</span> _vr.size();}
<a name="l00104"></a>00104 
<a name="l00106"></a><a class="code" href="classOpenBabel_1_1OBRotorRules.shtml#deb3abe4bd6c3443362068379a6b665e">00106</a>     <span class="keywordtype">void</span> SetFilename(std::string &amp;s)       { _filename = s;    }
<a name="l00107"></a>00107 
<a name="l00114"></a>00114     <span class="keywordtype">void</span> GetRotorIncrements(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a>&amp; mol,<a class="code" href="classOpenBabel_1_1OBBond.shtml" title="Bond class.">OBBond</a>* bond,<span class="keywordtype">int</span> refs[4],
<a name="l00115"></a>00115                             std::vector&lt;double&gt; &amp;vals,<span class="keywordtype">double</span> &amp;delta);
<a name="l00117"></a><a class="code" href="classOpenBabel_1_1OBRotorRules.shtml#3bf46031273468cc23720df1c59d3e85">00117</a>     <span class="keywordtype">void</span> Quiet()                           { _quiet=<span class="keyword">true</span>;      }
<a name="l00118"></a>00118   };
<a name="l00119"></a>00119 
<a name="l00122"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml">00122</a>   <span class="keyword">class </span>OBAPI <a class="code" href="classOpenBabel_1_1OBRotor.shtml" title="A single rotatable OBBond as part of rotamer searching.">OBRotor</a>
<a name="l00123"></a>00123   {
<a name="l00124"></a>00124     <span class="keywordtype">int</span> _idx,_ref[4];
<a name="l00125"></a>00125     <span class="keywordtype">int</span> *_rotatoms,_size,_numcoords;
<a name="l00126"></a>00126     <span class="keywordtype">double</span> _delta;
<a name="l00127"></a>00127     <span class="keywordtype">double</span> _imag,_refang;
<a name="l00128"></a>00128     <a class="code" href="classOpenBabel_1_1OBBond.shtml" title="Bond class.">OBBond</a> *_bond;
<a name="l00129"></a>00129     std::vector&lt;int&gt; _torsion;
<a name="l00130"></a>00130     <a class="code" href="classOpenBabel_1_1OBBitVec.shtml" title="A speed-optimized vector of bits.">OBBitVec</a> _fixedatoms,_evalatoms;
<a name="l00131"></a>00131     std::vector&lt;double&gt; _res;  
<a name="l00132"></a>00132     std::vector&lt;double&gt; _invmag;
<a name="l00133"></a>00133     std::vector&lt;std::vector&lt;double&gt; &gt; _sn,_cs,_t;
<a name="l00134"></a>00134   <span class="keyword">public</span>:
<a name="l00135"></a>00135     <a class="code" href="classOpenBabel_1_1OBRotor.shtml" title="A single rotatable OBBond as part of rotamer searching.">OBRotor</a>();
<a name="l00136"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#6a1a300dca75a2089732a7a66f7e1234">00136</a>     ~<a class="code" href="classOpenBabel_1_1OBRotor.shtml" title="A single rotatable OBBond as part of rotamer searching.">OBRotor</a>()
<a name="l00137"></a>00137       {
<a name="l00138"></a>00138         <span class="keywordflow">if</span> (_rotatoms)
<a name="l00139"></a>00139           <span class="keyword">delete</span> [] _rotatoms;
<a name="l00140"></a>00140       }
<a name="l00141"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#f40990b9bd3d70d30e8ce7cdda1ad56f">00141</a>     <span class="keywordtype">int</span>     Size()
<a name="l00142"></a>00142     {
<a name="l00143"></a>00143       <span class="keywordflow">return</span>((_res.empty())?0:_res.size());
<a name="l00144"></a>00144     }
<a name="l00145"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#c8451eabbc164153f5030ae9723cf48b">00145</a>     <span class="keywordtype">int</span>     GetIdx()<span class="keyword"> const</span>
<a name="l00146"></a>00146 <span class="keyword">    </span>{
<a name="l00147"></a>00147       <span class="keywordflow">return</span>(_idx);
<a name="l00148"></a>00148     }
<a name="l00149"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#4e82f80e2cd8faf3bce17c464ab1672c">00149</a>     <span class="keywordtype">void</span>    SetNumCoords(<span class="keywordtype">int</span> nc)
<a name="l00150"></a>00150     {
<a name="l00151"></a>00151       _numcoords = nc;
<a name="l00152"></a>00152     }
<a name="l00153"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#75c73979e73fb44e48424150fa0208c7">00153</a>     <span class="keywordtype">void</span>    SetBond(<a class="code" href="classOpenBabel_1_1OBBond.shtml" title="Bond class.">OBBond</a> *bond)
<a name="l00154"></a>00154     {
<a name="l00155"></a>00155       _bond = bond;
<a name="l00156"></a>00156     }
<a name="l00157"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#33bdb71641015f05a632ffaf76e7672a">00157</a>     <span class="keywordtype">void</span>    SetEvalAtoms(<a class="code" href="classOpenBabel_1_1OBBitVec.shtml" title="A speed-optimized vector of bits.">OBBitVec</a> &amp;bv)
<a name="l00158"></a>00158     {
<a name="l00159"></a>00159       _evalatoms = bv;
<a name="l00160"></a>00160     }
<a name="l00161"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#005953343bc86b4ef1300fc2fb00303c">00161</a>     <span class="keywordtype">void</span>    SetDihedralAtoms(std::vector&lt;int&gt; &amp;vi)
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163       _torsion = vi;
<a name="l00164"></a>00164     }
<a name="l00165"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#800aee2a9873012ac7e2a1bcedd5c6ba">00165</a>     <span class="keywordtype">void</span>    SetDelta(<span class="keywordtype">double</span> d)
<a name="l00166"></a>00166     {
<a name="l00167"></a>00167       _delta = d;
<a name="l00168"></a>00168     }
<a name="l00169"></a>00169     <span class="keywordtype">void</span>    SetDihedralAtoms(<span class="keywordtype">int</span> ref[4]);
<a name="l00170"></a>00170     <span class="keywordtype">void</span>    SetRotAtoms(std::vector&lt;int&gt;&amp;);
<a name="l00171"></a>00171 
<a name="l00172"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#bf3ad061350bb625d0343571eaa4d61e">00172</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> SetToAngle(<span class="keywordtype">double</span> *c,<span class="keywordtype">double</span> setang)
<a name="l00173"></a>00173     {
<a name="l00174"></a>00174       <span class="keywordtype">double</span> dx,dy,dz,sn,cs,t,ang,mag;
<a name="l00175"></a>00175       ang = setang - CalcTorsion(c);
<a name="l00176"></a>00176       <span class="keywordflow">if</span> (fabs(ang) &lt; 1e-5)
<a name="l00177"></a>00177         <span class="keywordflow">return</span>;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179       sn = sin(ang);
<a name="l00180"></a>00180       cs = cos(ang);
<a name="l00181"></a>00181       t = 1 - cs;
<a name="l00182"></a>00182       dx = c[_torsion[1]]   - c[_torsion[2]];
<a name="l00183"></a>00183       dy = c[_torsion[1]+1] - c[_torsion[2]+1];
<a name="l00184"></a>00184       dz = c[_torsion[1]+2] - c[_torsion[2]+2];
<a name="l00185"></a>00185       mag = sqrt(<a class="code" href="namespaceOpenBabel.shtml#30703c4e70c6142f64ceb67f1888b6e2">SQUARE</a>(dx) + <a class="code" href="namespaceOpenBabel.shtml#30703c4e70c6142f64ceb67f1888b6e2">SQUARE</a>(dy) + <a class="code" href="namespaceOpenBabel.shtml#30703c4e70c6142f64ceb67f1888b6e2">SQUARE</a>(dz));
<a name="l00186"></a>00186       Set(c,sn,cs,t,1.0/mag);
<a name="l00187"></a>00187     }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     <span class="keywordtype">void</span>    SetRotor(<span class="keywordtype">double</span> *,<span class="keywordtype">int</span>,<span class="keywordtype">int</span> prev=-1);
<a name="l00190"></a>00190     <span class="keywordtype">void</span>    Set(<span class="keywordtype">double</span>*,<span class="keywordtype">int</span>);
<a name="l00191"></a>00191     <span class="keywordtype">void</span>    Precompute(<span class="keywordtype">double</span>*);
<a name="l00192"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#6ad9188e396017a59a4c29ed1635d66f">00192</a>     <span class="keywordtype">void</span>    Set(<span class="keywordtype">double</span> *c,<span class="keywordtype">int</span> ridx,<span class="keywordtype">int</span> cidx)
<a name="l00193"></a>00193     {
<a name="l00194"></a>00194       Set(c,_sn[cidx][ridx],_cs[cidx][ridx],_t[cidx][ridx],_invmag[cidx]);
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196     <span class="keywordtype">void</span>    Set(<span class="keywordtype">double</span>*,<span class="keywordtype">double</span>,<span class="keywordtype">double</span>,<span class="keywordtype">double</span>,<span class="keywordtype">double</span>);
<a name="l00197"></a>00197     <span class="keywordtype">void</span>    Precalc(std::vector&lt;double*&gt;&amp;);
<a name="l00198"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#b994a975e39f5c62288f4f972b6f90c9">00198</a>     <span class="keywordtype">void</span>    SetIdx(<span class="keywordtype">int</span> idx)
<a name="l00199"></a>00199     {
<a name="l00200"></a>00200       _idx = idx;
<a name="l00201"></a>00201     }
<a name="l00202"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#530a0fd1a1e312d489b367ac73e56bb7">00202</a>     <span class="keywordtype">void</span>    SetFixedAtoms(<a class="code" href="classOpenBabel_1_1OBBitVec.shtml" title="A speed-optimized vector of bits.">OBBitVec</a> &amp;bv)
<a name="l00203"></a>00203     {
<a name="l00204"></a>00204       _fixedatoms = bv;
<a name="l00205"></a>00205     }
<a name="l00206"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#3928d417eca1dadd7ca997e9e553d4c5">00206</a>     <span class="keywordtype">void</span>    SetTorsionValues(std::vector&lt;double&gt; &amp;tmp)
<a name="l00207"></a>00207     {
<a name="l00208"></a>00208       _res = tmp;
<a name="l00209"></a>00209     }
<a name="l00210"></a>00210     <span class="keywordtype">void</span>    RemoveSymTorsionValues(<span class="keywordtype">int</span>);
<a name="l00211"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#44db679688b64e9032ea9bf6def76315">00211</a>     <span class="keywordtype">void</span>    GetDihedralAtoms(<span class="keywordtype">int</span> ref[4])
<a name="l00212"></a>00212     {
<a name="l00213"></a>00213       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;4;++i)
<a name="l00214"></a>00214         ref[i]=_ref[i];
<a name="l00215"></a>00215     }
<a name="l00216"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#a68d318d4f18049ca83fbbe8d1c5fa90">00216</a>     <span class="keywordtype">void</span>    *GetRotAtoms()
<a name="l00217"></a>00217     {
<a name="l00218"></a>00218       <span class="keywordflow">return</span>(_rotatoms);
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220     <span class="keywordtype">double</span>   CalcTorsion(<span class="keywordtype">double</span> *);
<a name="l00221"></a>00221     <span class="keywordtype">double</span>   CalcBondLength(<span class="keywordtype">double</span>*);
<a name="l00222"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#baa1b786f36fb9bc98b5c46e74425056">00222</a>     <span class="keywordtype">double</span>   GetDelta()
<a name="l00223"></a>00223     {
<a name="l00224"></a>00224       <span class="keywordflow">return</span>(_delta);
<a name="l00225"></a>00225     }
<a name="l00226"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#1b723190c734e234d87398f8eb245a8e">00226</a>     <a class="code" href="classOpenBabel_1_1OBBond.shtml" title="Bond class.">OBBond</a> *GetBond()
<a name="l00227"></a>00227     {
<a name="l00228"></a>00228       <span class="keywordflow">return</span>(_bond);
<a name="l00229"></a>00229     }
<a name="l00230"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#75d6cacf7c1783272f74546387716902">00230</a>     std::vector&lt;int&gt; &amp;GetDihedralAtoms()
<a name="l00231"></a>00231       {
<a name="l00232"></a>00232         <span class="keywordflow">return</span>(_torsion);
<a name="l00233"></a>00233       }
<a name="l00234"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#8feebfa38afe9888e7a50e421b8f5243">00234</a>     std::vector&lt;double&gt; &amp;GetResolution()
<a name="l00235"></a>00235       {
<a name="l00236"></a>00236         <span class="keywordflow">return</span>(_res);
<a name="l00237"></a>00237       }
<a name="l00238"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#06d5fdac08688bdff198a92c78bdeb69">00238</a>     std::vector&lt;double&gt;::iterator BeginTorIncrement()
<a name="l00239"></a>00239       {
<a name="l00240"></a>00240         <span class="keywordflow">return</span>(_res.begin());
<a name="l00241"></a>00241       }
<a name="l00242"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#c5857c1e09978240624038b2c6352dcc">00242</a>     std::vector&lt;double&gt;::iterator EndTorIncrement()
<a name="l00243"></a>00243       {
<a name="l00244"></a>00244         <span class="keywordflow">return</span>(_res.end());
<a name="l00245"></a>00245       }
<a name="l00246"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#b690ce98b2f06352f9079eeae94da3c4">00246</a>     <a class="code" href="classOpenBabel_1_1OBBitVec.shtml" title="A speed-optimized vector of bits.">OBBitVec</a> &amp;GetEvalAtoms()
<a name="l00247"></a>00247       {
<a name="l00248"></a>00248         <span class="keywordflow">return</span>(_evalatoms);
<a name="l00249"></a>00249       }
<a name="l00250"></a><a class="code" href="classOpenBabel_1_1OBRotor.shtml#937745b1178a21d8b223992d16d7d50a">00250</a>     <a class="code" href="classOpenBabel_1_1OBBitVec.shtml" title="A speed-optimized vector of bits.">OBBitVec</a> &amp;GetFixedAtoms()
<a name="l00251"></a>00251       {
<a name="l00252"></a>00252         <span class="keywordflow">return</span>(_fixedatoms);
<a name="l00253"></a>00253       }
<a name="l00254"></a>00254   };
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00258"></a><a class="code" href="namespaceOpenBabel.shtml#434f394d0613a8ef6c119670ff49710f">00258</a>   <span class="keyword">typedef</span> std::vector&lt;OBRotor*&gt;::iterator <a class="code" href="namespaceOpenBabel.shtml#434f394d0613a8ef6c119670ff49710f" title="A standard iterator over a vector of rotors.">OBRotorIterator</a>;
<a name="l00259"></a>00259 
<a name="l00262"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml">00262</a>   <span class="keyword">class </span>OBAPI <a class="code" href="classOpenBabel_1_1OBRotorList.shtml" title="Given an OBMol, set up a list of possibly rotatable torsions,.">OBRotorList</a>
<a name="l00263"></a>00263   {
<a name="l00264"></a>00264     <span class="keywordtype">bool</span> _quiet;                    
<a name="l00265"></a>00265     <span class="keywordtype">bool</span> _removesym;                
<a name="l00266"></a>00266     <a class="code" href="classOpenBabel_1_1OBBitVec.shtml" title="A speed-optimized vector of bits.">OBBitVec</a> _fix;                  
<a name="l00267"></a>00267     <a class="code" href="classOpenBabel_1_1OBRotorRules.shtml" title="Database of default hybridization torsional rules and SMARTS-defined OBRotorRule...">OBRotorRules</a> _rr;               
<a name="l00268"></a>00268     std::vector&lt;int&gt; _dffv;         
<a name="l00269"></a>00269     std::vector&lt;OBRotor*&gt; _rotor;   
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     std::vector&lt;std::pair&lt;OBSmartsPattern*,std::pair&lt;int,int&gt; &gt; &gt; _vsym2;
<a name="l00273"></a>00273     std::vector&lt;std::pair&lt;OBSmartsPattern*,std::pair&lt;int,int&gt; &gt; &gt; _vsym3;
<a name="l00274"></a>00274   <span class="keyword">public</span>:
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     <a class="code" href="classOpenBabel_1_1OBRotorList.shtml" title="Given an OBMol, set up a list of possibly rotatable torsions,.">OBRotorList</a>();
<a name="l00277"></a>00277     ~<a class="code" href="classOpenBabel_1_1OBRotorList.shtml" title="Given an OBMol, set up a list of possibly rotatable torsions,.">OBRotorList</a>();
<a name="l00278"></a>00278 
<a name="l00280"></a>00280     <span class="keywordtype">void</span>   Clear();
<a name="l00281"></a>00281 
<a name="l00283"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#f40990b9bd3d70d30e8ce7cdda1ad56f">00283</a>     <span class="keywordtype">int</span>    Size()
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285       <span class="keywordflow">return</span>((_rotor.empty()) ? 0: _rotor.size());
<a name="l00286"></a>00286     }
<a name="l00288"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#ddb143a5ae2f64420fa692a14489288b">00288</a>     <span class="keywordtype">void</span>   Init(std::string &amp;fname)
<a name="l00289"></a>00289     {
<a name="l00290"></a>00290       _rr.SetFilename(fname);
<a name="l00291"></a>00291       _rr.Init();
<a name="l00292"></a>00292     }
<a name="l00294"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#15266fb4e5ef334d0de47b203d420f22">00294</a>     <span class="keywordtype">void</span>   SetQuiet()      { _quiet=<span class="keyword">true</span>; _rr.Quiet();     }
<a name="l00295"></a>00295 
<a name="l00297"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#aabb93aa1f24c335405418bfa3ead95b">00297</a>     <span class="keywordtype">void</span>   SetFixAtoms(<a class="code" href="classOpenBabel_1_1OBBitVec.shtml" title="A speed-optimized vector of bits.">OBBitVec</a> &amp;fix) { _fix = fix;        }
<a name="l00298"></a>00298 
<a name="l00301"></a>00301     <span class="keywordtype">bool</span>   IsFixedBond(<a class="code" href="classOpenBabel_1_1OBBond.shtml" title="Bond class.">OBBond</a>*);
<a name="l00303"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#cb5c0375aa5f28091792762a5f66f23e">00303</a>     <span class="keywordtype">bool</span>   HasFixedAtoms()
<a name="l00304"></a>00304     {
<a name="l00305"></a>00305       <span class="keywordflow">return</span>(!_fix.Empty());
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307 
<a name="l00311"></a>00311     <span class="keywordtype">void</span>   SetRotAtomsByFix(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a>&amp;);
<a name="l00312"></a>00312 
<a name="l00317"></a>00317     <span class="keywordtype">bool</span>   SetRotAtoms(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a>&amp;);
<a name="l00318"></a>00318 
<a name="l00322"></a>00322     <span class="keywordtype">bool</span>   Setup(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a> &amp;);
<a name="l00326"></a>00326     <span class="keywordtype">bool</span>   FindRotors(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a> &amp;);
<a name="l00330"></a>00330     <span class="keywordtype">bool</span>   SetEvalAtoms(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a>&amp;);
<a name="l00333"></a>00333     <span class="keywordtype">bool</span>   AssignTorVals(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a> &amp;);
<a name="l00334"></a>00334 
<a name="l00337"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#dbf9e2936af60825abb7f7812ba8fae8">00337</a>     <span class="keywordtype">void</span>   IgnoreSymmetryRemoval()    { _removesym = <span class="keyword">false</span>;}
<a name="l00341"></a>00341     <span class="keywordtype">void</span>   RemoveSymVals(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a>&amp;);
<a name="l00342"></a>00342 
<a name="l00344"></a>00344 
<a name="l00345"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#0911c08e37e43925167a51149d143e3a">00345</a>     <a class="code" href="classOpenBabel_1_1OBRotor.shtml" title="A single rotatable OBBond as part of rotamer searching.">OBRotor</a> *BeginRotor(<a class="code" href="namespaceOpenBabel.shtml#434f394d0613a8ef6c119670ff49710f" title="A standard iterator over a vector of rotors.">OBRotorIterator</a> &amp;i)
<a name="l00346"></a>00346       { i = _rotor.begin(); <span class="keywordflow">return</span>((i ==_rotor.end()) ? NULL:*i); }
<a name="l00347"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#610d31fe22e09be685d1bc3e90584e56">00347</a>     <a class="code" href="classOpenBabel_1_1OBRotor.shtml" title="A single rotatable OBBond as part of rotamer searching.">OBRotor</a> *NextRotor(<a class="code" href="namespaceOpenBabel.shtml#434f394d0613a8ef6c119670ff49710f" title="A standard iterator over a vector of rotors.">OBRotorIterator</a> &amp;i)
<a name="l00348"></a>00348       { ++i; <span class="keywordflow">return</span>((i ==_rotor.end()) ? NULL:*i); }
<a name="l00349"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#9168b57d7fd7c6ac082ab7349e6c82df">00349</a>     <a class="code" href="namespaceOpenBabel.shtml#434f394d0613a8ef6c119670ff49710f" title="A standard iterator over a vector of rotors.">OBRotorIterator</a> BeginRotors()   { <span class="keywordflow">return</span>(_rotor.begin()); }
<a name="l00350"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#ac6c765496e1602cdf8a2160251cce9e">00350</a>     <a class="code" href="namespaceOpenBabel.shtml#434f394d0613a8ef6c119670ff49710f" title="A standard iterator over a vector of rotors.">OBRotorIterator</a> EndRotors()     { <span class="keywordflow">return</span>(_rotor.end());   }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     <span class="comment">// Not declared</span>
<a name="l00355"></a><a class="code" href="classOpenBabel_1_1OBRotorList.shtml#f5b2891615e85e4fb9ff52d2931c6170">00355</a> <span class="comment"></span>    <span class="keywordtype">bool</span>   IdentifyEvalAtoms(<a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a> &amp;mol) { <span class="keywordflow">return</span> SetEvalAtoms(mol); } 
<a name="l00356"></a>00356   };
<a name="l00357"></a>00357 
<a name="l00359"></a>00359   <span class="keyword">class </span>rotor_digit {
<a name="l00360"></a>00360     <span class="keyword">public</span>:
<a name="l00361"></a>00361       rotor_digit(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rs)
<a name="l00362"></a>00362       {
<a name="l00363"></a>00363         resolution_size = rs;
<a name="l00364"></a>00364         state = 0;
<a name="l00365"></a>00365       }
<a name="l00366"></a>00366       
<a name="l00367"></a>00367       rotor_digit()
<a name="l00368"></a>00368       {
<a name="l00369"></a>00369         resolution_size = 0;
<a name="l00370"></a>00370         state = 0;
<a name="l00371"></a>00371       }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373       <span class="keywordtype">void</span> set_size(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rs)
<a name="l00374"></a>00374       {
<a name="l00375"></a>00375         resolution_size = rs;
<a name="l00376"></a>00376         state = 0;
<a name="l00377"></a>00377       }
<a name="l00378"></a>00378       
<a name="l00379"></a>00379       <span class="keywordtype">void</span> set_state(<span class="keywordtype">int</span> st)
<a name="l00380"></a>00380       {
<a name="l00381"></a>00381         state = st;
<a name="l00382"></a>00382       }
<a name="l00383"></a>00383       
<a name="l00384"></a>00384       <span class="keywordtype">int</span> get_state()
<a name="l00385"></a>00385       {
<a name="l00386"></a>00386         <span class="keywordflow">return</span> state;
<a name="l00387"></a>00387       }
<a name="l00388"></a>00388       
<a name="l00389"></a>00389       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size()
<a name="l00390"></a>00390       {
<a name="l00391"></a>00391         <span class="keywordflow">return</span> resolution_size;
<a name="l00392"></a>00392       }
<a name="l00393"></a>00393       
<a name="l00394"></a>00394       <span class="keywordtype">bool</span> next()
<a name="l00395"></a>00395       {
<a name="l00396"></a>00396         <span class="keywordflow">if</span> (state&lt;resolution_size - 1) {
<a name="l00397"></a>00397           state++;
<a name="l00398"></a>00398           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00399"></a>00399         } <span class="keywordflow">else</span>
<a name="l00400"></a>00400           state = 0;
<a name="l00401"></a>00401         
<a name="l00402"></a>00402         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00403"></a>00403       }
<a name="l00404"></a>00404     <span class="keyword">private</span>:
<a name="l00405"></a>00405       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> resolution_size;
<a name="l00406"></a>00406       <span class="keywordtype">int</span> state;
<a name="l00407"></a>00407   } <span class="keyword">typedef</span> rotor_digit;
<a name="l00409"></a>00409   
<a name="l00412"></a><a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml">00412</a>   <span class="keyword">class </span>OBAPI <a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml" title="A class to generate all possible rotorKeys.">OBRotorKeys</a>
<a name="l00413"></a>00413   {
<a name="l00459"></a>00459     <span class="keyword">public</span>:
<a name="l00461"></a><a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml#1df6b471196fede2ca7816bdb48a55c4">00461</a>       <a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml" title="A class to generate all possible rotorKeys.">OBRotorKeys</a>()
<a name="l00462"></a>00462       {
<a name="l00463"></a>00463         _vr.clear();
<a name="l00464"></a>00464       }
<a name="l00465"></a>00465       
<a name="l00467"></a><a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml#a71d36872f416feaa853788a7a7a7ef8">00467</a>       <span class="keywordtype">void</span> Clear(){
<a name="l00468"></a>00468         _vr.clear();
<a name="l00469"></a>00469       }
<a name="l00470"></a>00470       
<a name="l00472"></a><a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml#5e2ff872d231d1a136588edf2f214812">00472</a>       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NumKeys()
<a name="l00473"></a>00473       {
<a name="l00474"></a>00474         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numKeys = 0;
<a name="l00475"></a>00475         
<a name="l00476"></a>00476         <span class="keywordflow">while</span> (Next())
<a name="l00477"></a>00477           numKeys++;
<a name="l00478"></a>00478         
<a name="l00479"></a>00479         <span class="keywordflow">return</span> numKeys;        
<a name="l00480"></a>00480       }
<a name="l00481"></a>00481 
<a name="l00484"></a><a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml#978846687be54138173a299d169bce37">00484</a>       <span class="keywordtype">void</span> AddRotor(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size)
<a name="l00485"></a>00485       {
<a name="l00486"></a>00486         rotor_digit *rd;
<a name="l00487"></a>00487         rd = <span class="keyword">new</span> rotor_digit(size);
<a name="l00488"></a>00488         _vr.push_back(*rd);
<a name="l00489"></a>00489       }
<a name="l00490"></a>00490       
<a name="l00493"></a><a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml#3947d19ac087ef2cd68c2409920339c4">00493</a>       <span class="keywordtype">bool</span> Next()
<a name="l00494"></a>00494       {
<a name="l00495"></a>00495         <span class="keywordflow">if</span>(_vr.size() == 0)
<a name="l00496"></a>00496           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00497"></a>00497         
<a name="l00498"></a>00498         <span class="keywordtype">bool</span> carry = _vr[0].next();
<a name="l00499"></a>00499         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;
<a name="l00500"></a>00500         <span class="keywordflow">while</span> (carry) {
<a name="l00501"></a>00501           <span class="keywordflow">if</span>(i == _vr.size())
<a name="l00502"></a>00502             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00503"></a>00503           
<a name="l00504"></a>00504           carry = _vr[i].next();
<a name="l00505"></a>00505           i++;
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00508"></a>00508       }
<a name="l00509"></a>00509       
<a name="l00512"></a><a class="code" href="classOpenBabel_1_1OBRotorKeys.shtml#0ea664b7db8e291318eda525a542aa7f">00512</a>       std::vector&lt;int&gt; GetKey()
<a name="l00513"></a>00513       {
<a name="l00514"></a>00514         std::vector&lt;int&gt; rt;
<a name="l00515"></a>00515         rt.clear();
<a name="l00516"></a>00516         rt.push_back(0);
<a name="l00517"></a>00517         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; _vr.size(); i++){
<a name="l00518"></a>00518           rt.push_back(_vr[i].get_state());
<a name="l00519"></a>00519         }
<a name="l00520"></a>00520         
<a name="l00521"></a>00521         <span class="keywordflow">return</span> rt;
<a name="l00522"></a>00522       }
<a name="l00523"></a>00523     
<a name="l00524"></a>00524     <span class="keyword">private</span>:
<a name="l00525"></a>00525       std::vector&lt;rotor_digit&gt; _vr;
<a name="l00526"></a>00526   };
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 } <span class="comment">// end namespace OpenBabel</span>
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="preprocessor">#endif // OB_ROTOR_H</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span>
</pre></div></div>
</div><!-- end content -->

<!--#include file="footer.html" -->

<div id="footer">
<hr size="1">
<img src="http://openbabel.org/babel256.png" width="136" height="127" alt="" style="float: left;" />
<p>This file is part of the documentation for <a href="http://openbabel.org/wiki/">Open Babel</a>, version 2.2.0.</p>
<div class="bottom">
Documentation copyright &copy; 1998-2007, the <a href="http://openbabel.org/wiki/THANKS">Open Babel Developers</a>.<br>
Open Babel is hosted by: <a href="http://sourceforge.net">
<img src="http://sourceforge.net/sflogo.php?group_id=40728" 
width="88" height="31" border="0" alt="SourceForge Logo"></a><br>
Generated on Thu Jul 3 14:30:34 2008 by&nbsp;<a href="http://www.doxygen.org/"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6.
</div>

</body>
</html>
